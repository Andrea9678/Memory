# Memory 内存

C++与内存

* C++中的栈内存和堆内存的区别  

  数据结构中的堆与栈：    
  栈：是一种连续储存的数据结构，具有先进后出的性质。通常的操作有入栈（圧栈）、出栈和栈顶元素。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比现实中的箱子一样。  
  堆：是一种非连续的树形储存数据结构，每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。  

  内存中的栈区与堆区：  
  一般说到内存，指的是计算机的随机储存器（RAM），程序都在这里面运行。计算机内存的大致划分如下图所示：  
  ![Image text](https://images2015.cnblogs.com/blog/928019/201607/928019-20160719170222107-1820485296.png)  
  栈内存：由程序自动向操作系统申请分配以及回收，速度快，使用方便，但程序员无法控制。若分配失败，则提示栈溢出错误。注意，const局部变量也储存在栈区内，栈区向地址减小的方向增长。  
  ```C  
  //测试堆内存和栈内存的区别
  #include <iostream>
  int main()
  {
      int i = 10; //变量i储存在栈区中
      char pc[] = "hello!"; //储存在栈区
      const double cd = 99.2; //储存在栈区
      static long si = 99; //si储存在可读写区，专门用来储存全局变量和静态变量的内存
      int* pi = new int(100); //指针pi指向的内存是在 堆区，专门储存程序运行时分配的内存
      std::cout << &i << " " << &pc << " " << &cd << " " << &si << " " << pi << std::endl;
      delete pi; //需程序员自己释放
      return 0;
  }
  ```   
  测试输出为：  
  ![Image text](https://images2015.cnblogs.com/blog/928019/201607/928019-20160719170537091-233465737.png)  
  运行多次后会发现pi所指向的地址并不连续，是跳跃式的；而&si是一致的，储存在可读写区；前三个变量都储存在栈区，由程序自动分配和销毁。 
  
* 内存的申请与释放  
  申请和释放某一个类型的内存方法：
  ```C
  int *p = new int;  
  delete p;  
  ```
  申请块内存的方法
  ```C
  int *arr = new int[10];
  delete []arr;
  ```
  判断内存是否申请成功
  ```C
  int *p =new int [100000];
  if(NULL == p)
  {
      cout<<"内存申请失败"<<endl;
  }  
  ```
  
* 内存泄漏  
  C++中内存泄漏的几种情况  
  
  1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
  两种情况下会出现这种内存泄露：
    一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；  
    二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存。

  2. 没有正确地清除嵌套的对象指针

  3. 在释放对象数组时在delete中没有使用方括号
  方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。

  释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。

  4. 指向对象的指针数组不等同于对象数组
  对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间。  
  指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。
  
* 深拷贝与浅拷贝  
  浅拷贝是增加了一个指针，指向原来已经存在的内存，在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误。而深拷贝是增加了一个指针，并新开辟了一块空间让指针指向这块新开辟的空间。


