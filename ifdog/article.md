
# 内存分区
- 栈内存:保存局部变量，不需显式释放内存，内存会在离开作用域时自动释放。该区域访问速度快，但容量小。
- 堆内存:存放new出来的对象，需要手动delete释放。如果忘记释放会导致内存泄漏。
- 自由存储:存放malloc分配的数据，需要手动free来释放。如果忘记释放会导致内存泄漏。
- 全局/静态存储区:存放全局的或静态的变量。
- 常量存储区:存放不可修改的常量字符串。
# 堆和栈的区别
- 堆通常靠人手工管理，栈靠编译器自动管理。
- 堆内存很大，可达数G字节的空间，而堆通常只有上M字节的空间。
- 堆内存的先进后出特性决定它容易产生碎片，降低效率，而栈内存不会。
- 堆内存向地址增加的方向生长，栈内存向地址减少的方向生长。
- 堆内存效率低，栈内存效率高。
# 常见的内存错误
- 未分配内存却使用了它。
```C
char *p;   //此时p为野指针
```
- 分配了内存，却未初始化。
```C
char revBuf[100];
printf("%s", revBuf);
```
↓↓↓↓↓↓↓↓↓↓↓↓ 
烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫....
- 对内存的操作越过了内存的边界。
```C
char *p=new char[3];  //分配三个字符空间，p指向该内存空间
strcpy(p,"abcd");  //将abcd存处在分配的内存空间中，由于strlen("abcd")=4>3，越界
delete []p;  //释放时出错
```
- 忘记释放内存，造成内存泄露。
```C
char *p=new char[3];  //分配三个字符空间，p指向该内存空间
p="ab"；   //此时p指向常量“ab”,而不再是new char分配的内存空间了，从而造成了资源泄漏
delete []p;         //释放时报错
```
- 释放了内存，却继续使用它。
```C
char *p=new char[10];  //指向堆中分配的内存首地址
cin>> p;
delete []p; //p重新变为野指针
```


```C
#include <iostream>
int main()
{
    int i = 10; //变量i储存在栈区中
    char pc[] = "hello!"; //储存在栈区
    static long si = 99; //储存在全局/静态存储区
    const double cd = 99.2; //储存在栈区
    int* pi = new int(100); //指针pi指向的内存是在堆区，专门储存程序运行时分配的内存
    delete pi; //自己释放
    return 0;
}
```
new的例子
```C
new int  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址
new int(100)  //同上，并指定该整数的初值为100
new char[100] //开辟一个存放字符数组（100个元素）的空间，返回首地址
new int[4][5]//开辟一个存放二维数组的空间，返回首元素的地址
float *p=new float(3.14157) //开辟一个存放单精度的空间，并指定该数的初值为3.14157，
                              将返回的该空间的地址赋给指针变量p
```

delete删除单变量的例子
```C
int *a = new int;
delete a;
```

delete删除数组空间的例子
```C
int *a = new int[5];
delete []a; 
```
